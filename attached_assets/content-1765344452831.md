Abstract

MaxFlow is **neutral reputation infrastructure** that converts public binary endorsements ("vouches") into verifiable graph signals using max-flow/min-cut algorithms and recursive trust weighting. Unlike centralized reputation systems that act as gatekeepers, MaxFlow computes mathematical signals that applications interpret according to their own policies—for creditworthiness, governance weight, access control, or grant allocation.

The system produces two complementary score families per epoch:

LocalHealth (0-100)

Personal network quality score computed by an iterative algorithm where each incoming vouch is weighted by the voucher's own score—creating recursive trust propagation. No seeds required.

STS — Standardized Trust Score (0-100)

Community score built on Advogato-style max-flow/min-cut from community-managed seeds, with robust percentile normalization and epoch-lagged capacities to prevent gaming.

Core Design Properties

**Accountability** — Outgoing vouches incur dilution penalties, creating economic cost for endorsement spam

**Epoch-lagged capacities** — Distance-based node capacities use the previous epoch's graph to prevent distance inflation attacks

**Separation of concerns** — Reward layers (e.g., KUDOS tokens) consume scores but never influence them

**Verifiability** — Parameters, Merkle roots, and signed outputs are published per epoch for independent verification

## 1. Introduction & Motivation

The Sybil Problem

In any open network where identity is cheap or free, adversaries can create arbitrarily many fake accounts to amplify their influence. This **Sybil attack** (Douceur, 2002) fundamentally undermines:

**Democratic governance** — One-person-one-vote collapses when one person controls thousands of accounts

**Quadratic funding** — Matching algorithms assume independent contributors, not coordinated Sybil farms

**Reputation systems** — Fake reviews, astroturfing, and manufactured consensus become trivial

**Airdrops & incentives** — Token distributions intended for unique participants get captured by farmers

Why Existing Solutions Fall Short

Current approaches to Sybil resistance each introduce significant trade-offs:

Proof-of-Stake / Economic Barriers

Requiring capital to participate excludes legitimate users without resources. Wealthy attackers can still Sybil by spreading stake across accounts. The cure—plutocracy—may be worse than the disease.

Centralized Attestation (KYC, Biometrics)

Services like Worldcoin or traditional KYC create single points of failure, privacy violations, and exclusion of those without government IDs. They also concentrate power in the attestation provider.

Social Verification (BrightID, PoH)

Requiring in-person verification or video calls limits scale and accessibility. Coverage remains sparse, and the systems still depend on trusted verifiers who could be compromised.

Aggregated Attestations (Gitcoin Passport)

Combining multiple signals improves robustness but still depends on external providers. Each attestation has its own gaming vectors, and the aggregation logic introduces centralized trust.

The MaxFlow Approach

MaxFlow takes a different path: instead of trying to verify identity through external attestations, we measure **graph topology and network structure**. The algorithm doesn't care about sincerity—it just makes gaming computationally and economically expensive through network properties:

Well-Connected Accounts

- • Multiple independent endorsers
- • Deep upstream support chains
- • Endorsers have their own high scores
- • Diverse path redundancy

Sybil Accounts

- • Few or no high-score endorsers
- • Shallow endorsement chains
- • Endorsers are also low-quality Sybils
- • Single point of failure (controller)

By weighting vouches recursively—your score depends on the scores of those who vouch for you—we create a system where Sybil accounts cannot bootstrap themselves. A cluster of fake accounts vouching for each other gets low scores because none of them have high-quality endorsers. Well-connected accounts embedded in dense networks accumulate higher scores through multiple independent paths.

Design Principles

1.

**Neutrality** — Scores are mathematical signals; applications decide their meaning

2.

**Verifiability** — Deterministic computation from public data with signed attestations

3.

**Accountability** — Endorsing has costs; spam reduces your own score

4.

**Separation** — Economic rewards never influence graph-based scoring

Nature-Inspired Design

MaxFlow deliberately leverages **network dynamics with billions of years of optimization** behind them. Rivers, roots, and ecosystems solve the same problems: maximize flow, build redundancy, prune freeloaders. This isn't coincidence—it's a power feature:

River Networks

Rivers find optimal paths to the sea through topology alone—no central planner. Our max-flow algorithm computes the same: how much "trust" can flow from sources to sinks through the network.

Graph property: Max-flow capacity

Root Systems

Stronger roots get more nutrients, enabling more growth—a recursive feedback loop. Our iterative algorithm works identically: vouches from high-score users carry more weight.

Graph property: Recursive trust weighting

Mycorrhizal Networks

Forest "wood-wide webs" distribute nutrients through redundant paths—no single tree failure collapses the network. Our min-cut component rewards exactly this: multiple independent connection paths.

Graph property: Path redundancy

Ecosystem Pruning

Species that take without contributing eventually get excluded from symbiotic networks. Our dilution penalty works the same way: over-vouching dilutes your score, creating natural accountability.

Graph property: Outgoing vouch penalty

"Trust, computed naturally. Graph algorithms engineered to leverage the same network dynamics that make rivers find paths, roots grow strong, and ecosystems self-regulate. Proven patterns. Ungameable by design."

## 2. Related Work & Comparison

MaxFlow builds on decades of research in trust metrics, graph algorithms, and Sybil resistance. Understanding these predecessors clarifies our design choices and trade-offs.

Advogato 1998

Max-Flow Trust Metrics

Raph Levien's pioneering work used max-flow from trusted seeds to bound the influence of attackers. The key insight: an attacker can only gain as much trust as they can "flow" through existing endorsements, naturally limiting Sybil influence.

MaxFlow extends: We add epoch-lagged capacities (preventing distance inflation), seed quality scoring (preventing seed capture), and robust percentile normalization (stable scores across graph sizes).

EigenTrust 2003

Iterative Trust Propagation

Kamvar et al. applied PageRank-style iteration to P2P networks, propagating trust through transaction history. Trust scores converge through repeated matrix multiplication, naturally emphasizing well-connected, high-quality nodes.

MaxFlow improves: We use damped iteration with explicit convergence bounds, add accountability penalties for outgoing vouches, and separate flow-based scoring from redundancy metrics for clearer semantics.

Personalized PageRank

Seed-Relative Scoring

Computing PageRank with restarts to a seed set provides personalized trust views. Each community can have its own perspective on which nodes are trustworthy, avoiding global consensus requirements.

MaxFlow incorporates: STS includes seed-personalized PageRank as a 5% component, combining it with max-flow for robustness against PageRank's sensitivity to high-degree nodes.

| System | Mechanism | Strengths | Weaknesses |
| --- | --- | --- | --- |
| Advogato | Max-flow from seeds | Provable attack bounds | Seed capture, static capacities |
| EigenTrust | Iterative propagation | Simple, scalable | Pre-trusted capture, convergence quirks |
| BrightID | Social verification | High assurance | Low coverage, centralized verifiers |
| Gitcoin Passport | Aggregated attestations | Multi-signal robustness | Depends on external providers |
| MaxFlow | Recursive trust + max-flow | Self-contained, accountable | Cold start for new networks |

## 3. System Architecture

Graph Model

The endorsement graph G=(V,E)G = (V, E)G=(V,E) is a directed graph where:

V

User accounts identified by Ethereum addresses (normalized to lowercase)

E

Binary endorsements e=(u→v)e = (u \\to v)e=(u→v) where user uuu vouches for user vvv, tagged with epoch and community

All endorsements are **public and immutable**. Each vouch is logged in a per-epoch Merkle tree, enabling anyone to audit the graph and independently verify score computations. This transparency is intentional: if you vouch for a bad actor, that connection is visible, creating social accountability.

Dual Scoring System

MaxFlow produces two complementary scores, each optimized for different use cases:

| Score | Range | Seeds Required | Best For |
| --- | --- | --- | --- |
| LocalHealth | 0-100 | No | Personal networks, cross-community portability |
| STS | 0-100 | Yes | Community-specific trust, access control |

Why Two Scores?

**LocalHealth** answers: "How much does the network trust this person?" It's computed without reference to any seed set, making it portable across communities. **STS** answers: "How trusted is this person within our specific community?" It uses community-managed seeds to anchor trust to that community's values.

Epoch System

Scores are computed in discrete **epochs** rather than continuously. This provides:

**Determinism** — Same inputs always produce same outputs, enabling independent verification

**Anti-gaming** — Epoch-lagged capacities prevent "distance inflation" attacks where adversaries manipulate their hop-distance from seeds within an epoch

**Attestations** — Each epoch publishes `params.json`,`seed_root`, `graph_root`, and signed `scores.jsonl` for verification

## 4. LocalHealth Algorithm

Intuition: Recursive Trust

The core insight behind LocalHealth is simple: **your trustworthiness depends on who trusts you, and their trustworthiness depends on who trusts them**. This creates a recursive relationship where high-quality vouchers contribute more to your score than low-quality ones.

Consider two users, Alice and Bob, each with 5 vouchers:

Alice's Vouchers

5 established community members with LocalHealth scores of 70-90. Each vouch carries significant weight.

Result: High LocalHealth

Bob's Vouchers

5 fresh accounts with LocalHealth scores of 10-20. The vouches carry little weight because the vouchers themselves aren't trusted.

Result: Low LocalHealth

This naturally penalizes Sybil clusters: a group of fake accounts vouching for each other all have low-quality vouchers (each other), so none can bootstrap to a high score.

Formal Definition

For user iii, we define the following quantities:

Vi\\mathcal{V}\_iVi​— Set of vouchers (users who endorse iii)

sj∈\[0,100\]s\_j \\in \[0,100\]sj​∈\[0,100\]— LocalHealth score of voucher jjj

**Direct Flow** — Sum of normalized voucher scores

Fi=∑j∈Visj100F\_i = \\sum\_{j \\in \\mathcal{V}\_i} \\frac{s\_j}{100}Fi​=∑j∈Vi​​100sj​​

**Flow Score** — Normalized against adaptive baseline

ϕi=min⁡ ⁣(1,Fi/F0)\\phi\_i = \\min\\!\\big(1, F\_i / F\_0\\big)ϕi​=min(1,Fi​/F0​)

**Adaptive F₀ (v1.2):** 75th percentile of incoming vouch counts, clamped to \[4, 15\]. Fallback: 8

**Dilution Factor (Piecewise Curve)** — Smooth penalty for over-vouching

1-10 vouches: D=1.0D = 1.0D=1.0 (no penalty)

11-15 vouches: D=1.0−0.03(v−10)D = 1.0 - 0.03(v-10)D=1.0−0.03(v−10) → 0.85

16-25 vouches: D=0.85−0.30⋅((v−15)/10)2D = 0.85 - 0.30\\cdot((v-15)/10)^2D=0.85−0.30⋅((v−15)/10)2 → 0.55

25+ vouches: asymptotic to 0.4

LocalHealth Score Formula (v1.4 — Linear Scaling)

LocalHealthi=60⋅ϕi+40⋅di⋅Di\\boxed{ \\mathrm{LocalHealth}\_i \\;=\\; 60 \\cdot \\phi\_i \\;+\\; 40 \\cdot d\_i \\cdot D\_i }LocalHealthi​=60⋅ϕi​+40⋅di​⋅Di​​

60% Flow Component

Who vouches for you, weighted by tiered capacity (0.08 floor for sockpuppets, sqrt scaling for high scores). High-quality vouchers matter more.

40% Structure Component

True min-cut (linear) × accountability penalty. Min-cut measures Sybil resistance via Dinic's algorithm, with bonuses for vertex-disjoint paths (up to 10 pts).

True Min-Cut Redundancy (v1.3)

We measure **structural redundancy** using the **true min-cut**—the minimum number of edges that must be removed to disconnect your trust sources from you. This is the core Sybil resistance metric, computed via Dinic's max-flow algorithm on the ego subgraph.

minCuti\\text{minCut}\_iminCuti​

True min-cut via Dinic's algorithm

u=∣Ui∣−ku = \|U\_i\| - ku=∣Ui​∣−k

Additional upstream supporters

vdp\\text{vdp}vdp

Vertex-disjoint path count

n=∣Ui∣n = \|U\_i\|n=∣Ui​∣

Total nodes in ego subgraph

Effective Redundancy (v1.4 — True Min-Cut)

ρi=minCuti+λdepth⋅u+min⁡(10,2⋅max⁡(0,vdp−1))\\rho\_i = \\text{minCut}\_i + \\lambda\_{\\text{depth}} \\cdot u + \\min(10, 2 \\cdot \\max(0, \\text{vdp} - 1))ρi​=minCuti​+λdepth​⋅u+min(10,2⋅max(0,vdp−1))

λdepth=0.1\\lambda\_{\\text{depth}} = 0.1λdepth​=0.1, vdp = vertex-disjoint paths, max VDP bonus = 10 pts

Why True Min-Cut? (v1.3 Enhancement)

Min-cut directly measures Sybil resistance: it's the number of fake accounts an attacker needs to create to fully disconnect you from the trust network. We compute this using Dinic's algorithm on a multi-hop flow graph built from your ego subgraph. Vertex-disjoint paths (computed via node splitting) add a bonus for having truly independent paths with no shared intermediate nodes.

The redundancy score di=min⁡(1,ρi/R0)d\_i = \\min(1, \\rho\_i / R\_0)di​=min(1,ρi​/R0​) normalizes against an **adaptive baseline**: R0=18.0R\_0 = 18.0R0​=18.0 (HEALTHY\_REDUNDANCY, computed from network percentiles). Users with high min-cut and diverse paths approach di=1d\_i = 1di​=1; isolated accounts stay near zero.

Iterative Computation (v1.2)

Because each user's score depends on their vouchers' scores, we compute LocalHealth iteratively across the entire network:

**1\. Initialize**

si(0)=min⁡(100,20∣Vi∣)s\_i^{(0)} = \\min(100, 20\\sqrt{\|\\mathcal{V}\_i\|})si(0)​=min(100,20∣Vi​∣​) — bootstrap from vouch count

**2\. Compute (network-wide)**

Compute si(t+1)s\_i^{(t+1)}si(t+1)​ for ALL users using current voucher scores

**3\. Replace directly**

si(t+1)=computed scores\_i^{(t+1)} = \\text{computed score}si(t+1)​=computed score(no damping in v1.2)

**4\. Converge**

Stop when max⁡i∣si(t+1)−si(t)∣<0.5\\max\_i \|s\_i^{(t+1)} - s\_i^{(t)}\| < 0.5maxi​∣si(t+1)​−si(t)​∣<0.5 or after 10 rounds

Convergence Note (v1.2)

Damping was removed after empirical testing showed stable convergence in 4-6 iterations. The bounded voucher weights (0-1) and quadratic scaling naturally prevent oscillation. Scores are computed network-wide every 6 hours via scheduled batch recalculation.

Worked Example

Consider user Alice with 4 vouchers at iteration ttt:

| Voucher | Score sj(t)s\_j^{(t)}sj(t)​ | Contribution |
| --- | --- | --- |
| Bob | 75 | 0.75 |
| Carol | 60 | 0.60 |
| Dave | 80 | 0.80 |
| Eve | 45 | 0.45 |
| Direct Flow FAliceF\_{Alice}FAlice​ | 2.60 |

**Flow Score (with HEALTHY\_VOUCH\_COUNT=4.0):** ϕ=min⁡(1,2.60/4.0)=0.65\\phi = \\min(1, 2.60/4.0) = 0.65ϕ=min(1,2.60/4.0)=0.65

**Flow Points (v1.4 linear):** 60×0.65=39.060 \\times 0.65 = 39.060×0.65=39.0

**Assuming** d=0.7d = 0.7d=0.7 (redundancy), D=1.0D = 1.0D=1.0 (no dilution):

**Structure Points (v1.4 linear):** 40×0.7×1.0=28.040 \\times 0.7 \\times 1.0 = 28.040×0.7×1.0=28.0

LocalHealthAlice=39.0+28.0=67.0\\mathrm{LocalHealth}\_{Alice} = 39.0 + 28.0 = 67.0LocalHealthAlice​=39.0+28.0=67.0

Alice has a solid network. More vouchers from high-score users would increase her flow component further.

## 5. STS (Standardized Trust Score)

Community-Anchored Trust

While LocalHealth provides a global, seed-free measure, some applications need **community-specific trust**. A DAO might want to weight votes by trust within their community; a lending protocol might want to assess creditworthiness relative to their borrower pool.

STS uses the **Advogato max-flow algorithm** with community-managed seeds. Trust flows from seeds through the endorsement graph, with flow-conserving constraints limiting how much trust any node can transmit.

Graph Construction

We construct a flow network by splitting each user uuu into two nodes (u−,u+)(u^-, u^+)(u−,u+) with a capacity edge between them:

**Internal capacity** c(d)c(d)c(d) based on previous-epoch hop-distance from seeds

**Sink edge** u−→SINKu^- \\to \\text{SINK}u−→SINK with capacity 1 (each user can "consume" 1 unit of trust)

**Vouch edges** a+→b−a^+ \\to b^-a+→b− with capacity 1 for each endorsement

**Seed edges** SOURCE→seed−\\text{SOURCE} \\to \\text{seed}^-SOURCE→seed− with capacity scaled by seed quality score

Capacity Schedule (by hop-distance)

c(0)=800,c(1)=240,c(2)=96,c(3)=48,c(≥4)=24c(0)=800,\\; c(1)=240,\\; c(2)=96,\\; c(3)=48,\\; c(\\geq 4)=24c(0)=800,c(1)=240,c(2)=96,c(3)=48,c(≥4)=24

**Why epoch-lagged distances?** If we computed distance in the current epoch, an attacker could add edges to get closer to seeds and immediately gain higher capacity. By using previous-epoch distances, we prevent this "distance inflation" attack.

STS Formula

STS combines five normalized components:

FiF\_iFi​ — Normalized flow

55%

CiC\_iCi​ — Min-cut capacity

25%

DiD\_iDi​ — Depth decay

10%

SiS\_iSi​ — Stability score

5%

PRiPR\_iPRi​ — Seed-personalized PageRank

5%

STS Score Formula

STSi=100⋅(0.55Fi+0.25Ci+0.10Di+0.05Si+0.05PRi)\\boxed{\\mathrm{STS}\_i = 100 \\cdot \\big(0.55F\_i + 0.25C\_i + 0.10D\_i + 0.05S\_i + 0.05PR\_i\\big)}STSi​=100⋅(0.55Fi​+0.25Ci​+0.10Di​+0.05Si​+0.05PRi​)​

Tier Thresholds

ConnectedSTS ≥ 40

VerifiedSTS ≥ 60 AND min-cut ≥ 2

TrustedSTS ≥ 80 AND min-cut ≥ 3 AND Stability ≥ 0.8

## 6. Threat Model & Security

Attack Scenarios

Attack 1: Sybil Farm

Adversary creates N fake accounts that vouch for each other in a dense cluster, attempting to bootstrap high scores without external network connections.

Defense

Recursive trust weighting: Sybils vouching for Sybils produce low scores because no voucher has a high score. The cluster cannot bootstrap itself.

Attack 2: Seed Capture

Adversary compromises or bribes seed accounts to gain direct high-capacity flow into the Sybil cluster.

Defense

Seed quality scoring: Seeds that primarily flow trust to low-quality nodes get their capacity multiplier reduced. Diverse seed requirements (≥2 seeds with quality ≥0.6) prevent single-seed capture.

Attack 3: Bridge Hub

A high-score user is bribed or tricked into vouching for Sybil accounts, acting as a "bridge" between the established network and the attack cluster.

Defense

Dilution penalty: Users who vouch for many others (>10) suffer score reduction, limiting the value of being a "vouch merchant." Min-cut requirements ensure multiple independent paths, not just one bridge.

Attack 4: Distance Inflation

Adversary adds edges to reduce their hop-distance from seeds within an epoch, gaining higher capacity immediately.

Defense

Epoch-lagged capacities: Distance is computed from the previous epoch's accepted graph, so new edges only take effect in the next epoch.

Defense Summary

| Mechanism | Protects Against |
| --- | --- |
| Recursive trust weighting | Sybil farms (circular vouching) |
| Epoch-lagged capacities | Distance inflation attacks |
| Min-cut floors (≥2) | Single-path/bridge dependency |
| Seed quality scoring | Seed capture/corruption |
| Dilution penalty | Vouch spam, vouch selling |
| Public Merkle log | Undetected graph manipulation |

## 7. Evaluation Methodology

Theoretical Properties

MaxFlow's security properties derive from fundamental graph-theoretic guarantees:

Sybil Resistance Bound

The max-flow/min-cut theorem guarantees that an attacker's aggregate trust is bounded by the capacity of edges connecting their cluster to the established network. Isolated Sybil clusters receive zero flow; clusters with kkk bridges can gain at most kkk units of trust.

Recursive Dampening

Because vouch weights depend on voucher scores, Sybil clusters face a bootstrapping problem: low-quality vouchers contribute low-weight vouches, preventing score inflation even with dense internal connections.

Convergence Guarantee

With bounded vouch weights (0-1) and tiered capacity weighting, the iterative update converges to a unique fixed point regardless of initialization. Empirical testing shows stable convergence in 4-6 iterations with max change <0.5 at termination.

Evaluation Framework

To assess MaxFlow's effectiveness, we recommend evaluating against these attack scenarios:

A.

**Isolated Sybil Cluster**

N fake accounts vouching only for each other. Expected: all scores near zero.

B.

**Bridge Attack**

Sybil cluster with k bridges to established users. Expected: scores bounded by bridge capacity.

C.

**Seed Capture**

One seed compromised, vouching for Sybils. Expected: seed quality score degrades, limiting damage.

D.

**Vouch Merchant**

High-score user sells vouches to many buyers. Expected: dilution penalty reduces their score and vouch value.

Metrics to Track

For each scenario, measure: (1) AUC for distinguishing Sybils from established users by score, (2) false negative rate at various thresholds, (3) score distribution before/after attack.

Validated Test Scenarios

The algorithm has been validated against **51 test scenarios** covering legitimate networks, attack patterns, cross-network dynamics, and edge cases. Key empirical results:

Legitimate Network Scores

Healthy Mesh Network (10 users, bidirectional)82-99

Large Hub (51 vouchers)95

Multi-Whale Vouched User (4 quality sources)91

Gradual Integration (5 quality vouches)72

Attack Pattern Scores

Sybil Ring (6 accounts, circular vouching)37 max

Sockpuppet Farm (10 fake accounts → 1 target)55\*

Fake Hub (15 sockpuppets vouching)51

Fake Mesh Pattern (isolated dense cluster)7

Hybrid Attack (ring + fake mesh)18/5

Isolated Newcomer Cluster (no external links)5-6

\*Sockpuppet Farm score boosted by legitimate Hub vouch in cross-network test

Key Sybil Resistance Validation

**Tiered Capacity:** 6 low-quality vouches (score 0) contribute only 0.48 flow (6 × 0.08) vs 4.0 healthy baseline—insufficient to boost targets

**Trust Cascade:** 5-hop chain shows proper attenuation (21 → 8 → 5)—trust decays with distance

**Whale Dilution:** Single ultra-voucher's recipients score 33 (diluted), vs 91 when vouched by 4 separate quality sources (redundancy bonus)

**Convergence:** Algorithm converges in 3-5 iterations for typical networks, with max change <0.5 at termination

Full test suite: 51 scenarios, 747 vouches, 509 users. Run via /api/admin/validate-algorithm

Unexpected Attack Scenarios

Additional edge-case scenarios designed to probe potential vulnerabilities:

Compromised Whale

Hacked high-score account vouches for sockpuppets

Whale: 88, Sockpuppets: 31 each

Protected

Parasitic Bridge

One legit account vouches for 50 sockpuppets

Bridge: 76, Each sockpuppet: 34

Protected

Reputation Laundering

A→B→C→Target chain from legitimate source

Target: 13 (proper attenuation)

Protected

Trojan Community

20-person fake mesh used as vouch factory

Members: 10-13 (isolated)

Protected

Dilution Sabotage

Attacker vouches for victim's vouchers to dilute

Victim: 83 (stable), Attacker: 0

Protected

Eclipse Attack

20 attackers surround target to isolate

Target: 85 (stable), Attackers: 5

Protected

Flash Mob Vouch

100 low-score accounts vouch for one target

Target: 52 (threshold >20 triggers cap)

Protected

Slow-Burn Sybil

Sleeper accounts activated for coordinated attack

Target: 50, Sleepers: 28-38

Protected

**Key Finding:** All 8 unexpected attack scenarios properly contained below the 65 "likely human" threshold. Flash Mob protection implemented via capped low-quality flow (max 2.0 from score-<30 sources) and quality-gated min-cut capacity. All sophisticated attacks (compromise, laundering, eclipse, flash mob) are effectively neutralized.

Confidence Tier Thresholds

Based on validated test scenarios, we recommend the following thresholds for human vs bot/attack confidence:

≥75

High Confidence

Almost certainly human with genuine network ties

≥65

Likely Human

Reasonable confidence with organic network redundancy

50-64

Uncertain

Could be legitimate newcomer OR sophisticated attack

<50

Low Confidence

Most attack patterns score in this range

Attack patterns (Sybil rings, fake hubs, sockpuppet farms) cluster below 60, while legitimate integration patterns score 70+. The 65 threshold balances false positives with security.

Algorithmic Complexity

Computational costs scale predictably with graph size:

LocalHealth (per user)

O(k⋅∣Eego∣)O(k \\cdot \|E\_{ego}\|)O(k⋅∣Eego​∣) where kkk is iteration count (≤10) and EegoE\_{ego}Eego​ is ego subgraph edges

STS (per community)

O(∣V∣2⋅∣E∣)O(\|V\|^2 \\cdot \|E\|)O(∣V∣2⋅∣E∣) for Dinic's algorithm on the flow network

Iteration Bound

Convergence threshold ε=0.5\\varepsilon = 0.5ε=0.5 with max 10 iterations ensures bounded compute time

Parallelization

Per-user LocalHealth is embarrassingly parallel; batch computation scales linearly with cores

## 8. Discussion & Limitations

Trade-offs

Cold Start Problem

New users with no vouches have zero score. Unlike attestation-based systems, there's no way to bootstrap without network connections. This is a feature (Sybil resistance) but creates friction for newcomers.

**Mitigation:** Communities can provide onboarding paths where established members vouch for newcomers they verify through other means.

Privacy vs. Auditability

Public endorsements enable verification but reveal social connections. Users must accept that their vouches are visible.

**Mitigation:** Future work on ZK proofs could allow proving score properties without revealing the graph.

Parameter Sensitivity

Baseline values (F0=4.0F\_0 = 4.0F0​=4.0, R0=18.0R\_0 = 18.0R0​=18.0) affect score distributions. Different network densities may need different parameters.

**Mitigation:** Adaptive baselines now auto-tune based on 75th percentile of network vouch counts, clamped to \[4, 15\].

Known Limitations

**Not real identity:** High scores indicate network integration, not verified uniqueness. A wealthy adversary with many real friends could still Sybil.

**Network effects matter:** Early adopters in a small network may have artificially high scores due to scarcity of connections.

**Collusion resistance is bounded:** If a large fraction of the network colludes, MaxFlow cannot distinguish colluders from honest users.

## 9. Implementation

Technology Stack

Backend

Node.js / TypeScript (Express)

Database

PostgreSQL (Drizzle ORM)

Frontend

React / Vite / Tailwind CSS

Auth

Multi-chain wallets + EIP-712 signatures

Performance

**LocalHealth:** Per-round update is O(∣E∣)O(\|E\|)O(∣E∣); ≤10 rounds without damping; trivially parallel per node

**STS:** Reusable residual graphs; Push-Relabel with global relabeling for efficient multi-flow computation

**Scheduled Recalculation:** Network-wide batch computation every 6 hours via RecalculationScheduler. Scores cached in database with algorithm breakdown.

**Caching:** Three-tier API: basic cached (sub-second), detailed cached (sub-second with breakdown), on-demand single-user (1-5s fresh computation)

API Reference

GET /api/v1/scores/cached

→ Basic bulk: address, score, timestamp (sub-second)

GET /api/v1/scores/cached/detailed

→ Detailed bulk: full algorithm breakdown from 6-hour cache

GET /api/v1/score/:address/details

→ On-demand: fresh computation for single address (1-5s)

POST /api/vouch

→ endorsee, signature (vouch recorded, batch recompute)

POST /api/vouch/revoke

→ endorsee, signature (revoke existing vouch)

GET /api/community/:id/sts/:addr

→ sts, F, C, S, D, PR, minCut, depth

## 10. Future Work

Recently Implemented (December 2025)

Vertex-Disjoint Paths

Node-splitting max-flow counts truly independent paths. Bonus redundancy for multiple disjoint paths (up to +10 points, 2 pts per path).

Piecewise Dilution Curves

Smooth non-linear penalties: 1-10 vouches = no penalty, 11-15 = gentle decay, 16-25 = steeper decay, 25+ = asymptotic floor.

Adaptive Baselines

Dynamic "healthy" thresholds computed from 75th percentile of network. Algorithm adapts as network grows.

Vouch Expiration

90-day validity window. Vouches remain valid if recipient is active (vouched recently). Prevents "set and forget" sockpuppet farms.

Vouch Revocation

EIP-712 signed revocation messages. Endorsers can revoke vouches at any time. Stored in endorsementTombstones table.

Flash Mob Protection

Detects coordinated mass-vouching (>20 low-score vouchers). Caps low-quality flow at 2.0. Flash mob targets score 52 instead of 99.

Security Hardening

- • Vertex-disjoint path checks ✓
- • Per-seed flow floors
- • Cut witnesses with Merkle proofs

Algorithm Improvements

- • Adaptive baselines ✓
- • Percentile-based tiers (display layer)
- • Piecewise dilution curves ✓

Feature Extensions

- • Vouch revocation/expiry ✓
- • Typed vouches (skill/credit)
- • Cross-community portability

## 11\. Conclusion

MaxFlow computes **neutral, verifiable graph signals** by pairing recursive trust with structural resilience and explicit accountability. Public vouches, epoch-lagged capacities, and signed attestations yield an auditable, Sybil-resistant foundation.

Applications consume these signals to:

Allocate capital (microcredit, grants)

Weight governance (DAO voting)

Gate access (communities, features)

Route grants (quadratic funding)

—without inheriting centralized choke points.

## References

1. \[1\]**Levien, R.** "Attack-Resistant Trust Metrics for Public Key Certification." USENIX Security (1998).
2. \[2\]**Kamvar, S., Schlosser, M., Garcia-Molina, H.** "The EigenTrust Algorithm for Reputation Management in P2P Networks." WWW (2003).
3. \[3\]**Douceur, J.** "The Sybil Attack." IPTPS (2002).
4. \[4\]**Ford, L., Fulkerson, D.** "Maximal Flow through a Network." Canadian Journal of Mathematics (1956).
5. \[5\]**Dinic, E.** "Algorithm for Solution of a Problem of Maximum Flow in Networks with Power Estimation." Soviet Mathematics Doklady (1970).

## Version History

Version 1.4 (December 2025)

**Adaptive Baselines**

HEALTHY\_VOUCH\_COUNT = 4.0, HEALTHY\_REDUNDANCY = 18.0 (computed from network percentiles). Enables algorithm to scale with network growth.

**Iteration Without Damping**

Removed α=0.85 damping factor. Direct score replacement shows stable 4-6 iteration convergence. Network-wide batch recalculation every 6 hours.

**Piecewise Dilution Curve**

Smooth 4-zone decay replacing linear penalty. Quality (1-10): 1.0, Warning (11-15): 1.0→0.85, Penalty (16-25): 0.85→0.55, Cap (25+): asymptotic to 0.4.

**Vertex-Disjoint Path Bonus**

+2 redundancy per independent path (capped at 10). Computed via max-flow with node splitting for stronger Sybil resistance.

**Linear Scaling**

Replaced squared formula with linear 60/40 weighting. Tiered capacity: 0.08 floor for sockpuppets, 0.08-0.30 linear for scores 1-30, 0.30-1.0 sqrt for scores 31+.

**Vouch Expiration & Revocation**

90-day validity window with activity-based retention. EIP-712 signed revocation support. Expired/revoked vouches excluded from scoring.

**Flash Mob Protection**

Threshold-based detection (>20 low-quality vouchers). Capped flow from sockpuppets (max 2.0). Quality-gated min-cut calculation.

**Three-Tier API**

Basic cached, detailed cached, and on-demand endpoints. 6-hour scheduled batch recalculation with algorithm breakdown caching.

Version 1.2 (November 2025)

Adaptive baselines, iteration without damping, piecewise dilution curves, vertex-disjoint path bonus.

Version 1.1 (October 2025)

Initial published specification. Fixed baselines F₀=5, R₀=20. Linear dilution with 50% floor. Damped iteration with α=0.85.