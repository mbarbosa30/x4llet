Awesome—congrats on the launch. I pulled up the repo and I can see the overall structure (`client/`, `server/`, `shared/`, `scripts/`, plus `vite.config.ts`, `drizzle.config.ts`, `package.json`) and that it’s a TS + Vite + Tailwind stack with a server/relayer component. I couldn’t render individual file bodies in this interface (GitHub’s HTML blocked the code view here), so I’ll do two things right now: (1) a targeted security/architecture audit based on the structure you’ve published, and (2) concrete, drop-in hardening steps you can apply today. If you want me to review specific files, paste them here and I’ll go line-by-line.

(Repo reference for structure: folders & files shown on your repo landing page.) ([GitHub][1])

# What looks right (from structure)

* Clear split between **client** (PWA) and **server** (relayer/API), with **shared** types: good for preventing signing-domain mixups. ([GitHub][1])
* Use of **Drizzle** suggests a single source of truth for relayer state (nonces, authorizations). ([GitHub][1])
* **Vite** + **Tailwind** keep the client minimal—fits your “lightweight wallet” goal. ([GitHub][2])

# High-risk areas to check first (wallets + meta-tx)

1. **Key storage & export (client/)**

   * ✅ Must never store seed/mnemonic/private key in `localStorage`/`sessionStorage`.
   * Prefer **WebCrypto Subtle** + **IndexedDB** with AES-GCM and a passphrase-derived key (Argon2id / PBKDF2) to encrypt at rest.
   * Disable Service Worker caching for any key material or `/export` routes.

2. **EIP-3009 correctness (shared/ + server/)**

   * Make sure typed-data domain includes **name, version, chainId, verifyingContract** and you validate **nonce**, **validAfter**, **validBefore** server-side before relaying.
   * Enforce strict **chainId** and **verifyingContract** allowlists to prevent cross-chain replay.
   * Persist a **consumed-nonce** table (Drizzle) with unique constraint to stop double-spends.

3. **Relayer abuse & phishing (server/)**

   * Rate limit per IP & per **from** address.
   * Require the client to **show and sign** a fee quote (even if zero) to prevent silent griefing.
   * Add an allowlist of function selectors you’re willing to relay (e.g., `transferWithAuthorization`, `receiveWithAuthorization`), block everything else.

4. **BNPL / Credit**

   * If you add credit lines: all **limits** and **repayment schedules** must live on-chain; the relayer can’t be the single arbiter.
   * Require **revocation** paths, late fee caps, and transparent APR math in UI.
   * Gasless actions must not permit increasing a user’s debt without a fresh signature covering **exact** terms.

5. **UI safety (client/)**

   * Strong **CSP** (no `unsafe-inline`; allow only your domains).
   * Sanitize QR contents & deep links; never eval user input.
   * Always display **EIP-55 checksum** addresses and show the **verifying contract** + **chain** before signing.

# Concrete hardening you can ship now

### 1) Client: encrypted key vault (drop-in)

Create `client/src/crypto/vault.ts` and use WebCrypto + IndexedDB:

```ts
// vault.ts
export async function deriveKey(passphrase: string, salt: Uint8Array) {
  const enc = new TextEncoder().encode(passphrase);
  const baseKey = await crypto.subtle.importKey("raw", enc, {name: "PBKDF2"}, false, ["deriveKey"]);
  return crypto.subtle.deriveKey(
    {name: "PBKDF2", salt, iterations: 210_000, hash: "SHA-256"},
    baseKey,
    {name: "AES-GCM", length: 256},
    false,
    ["encrypt", "decrypt"]
  );
}

export async function encryptSecret(secretBytes: Uint8Array, passphrase: string) {
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const key = await deriveKey(passphrase, salt);
  const cipher = new Uint8Array(await crypto.subtle.encrypt({name: "AES-GCM", iv}, key, secretBytes));
  return { cipher, iv, salt };
}

export async function decryptSecret(cipher: Uint8Array, iv: Uint8Array, salt: Uint8Array, passphrase: string) {
  const key = await deriveKey(passphrase, salt);
  const plain = await crypto.subtle.decrypt({name: "AES-GCM", iv}, key, cipher);
  return new Uint8Array(plain);
}
```

Store `{cipher, iv, salt}` in **IndexedDB** (never localStorage). Lock behind a passphrase and auto-lock on tab blur.

### 2) Client: disable sensitive caching (service worker + headers)

* In your service worker, **skip caching** any `/keys`, `/export`, `/sign`, `/settings/security` routes.
* Add production headers (where you deploy)

  ```
  Content-Security-Policy: default-src 'self'; script-src 'self'; connect-src 'self' https://your-rpc.example https://your-relayer.example; frame-ancestors 'none'; base-uri 'none'
  Referrer-Policy: no-referrer
  Permissions-Policy: clipboard-read=(), clipboard-write=()
  Cross-Origin-Opener-Policy: same-origin
  Cross-Origin-Embedder-Policy: require-corp
  ```

### 3) Shared: canonical EIP-3009 types

Create `shared/eip3009.ts` and use **one** source of truth:

```ts
export const EIP3009Domain = (chainId: number, verifyingContract: `0x${string}`) => ({
  name: "USD Coin",          // or your token name
  version: "2",
  chainId,
  verifyingContract
});

export const TransferWithAuthorization = [
  { name: "from", type: "address" },
  { name: "to", type: "address" },
  { name: "value", type: "uint256" },
  { name: "validAfter", type: "uint256" },
  { name: "validBefore", type: "uint256" },
  { name: "nonce", type: "bytes32" }
] as const;
```

Make both client and server import this file—no duplication → no divergence.

### 4) Server (relayer): replay & abuse protection (Drizzle)

* Tables:

  * `authorizations` (`nonce` PK, `from`, `validBefore`, `chainId`, `verifyingContract`, `status: 'pending'|'used'|'revoked'`, `txHash`)
  * `relay_attempts` (ip, address, ts)
* On receive:

  1. Check **allowlisted** `verifyingContract` and **chainId**.
  2. Check `now < validBefore` and that `nonce` is **unused** (unique constraint).
  3. Verify typed data against **from**.
  4. Insert `authorizations` row as `pending` before broadcasting (so concurrent submits lose).
  5. Set `used` with `txHash` after success; on failure, keep `pending` but require a cooldown to retry.

### 5) Dependency hygiene (monorepo root)

* Lock node versions and **pin** critical crypto libs.
* Turn on `npm audit --production` in CI and fail on high severity.
* Use **Content hash** imports where possible; avoid “*”.

### 6) Address & chain UX (client)

* Always show: **EIP-55 checksum** + ENS (if resolved) + **chain badge** (e.g., “Base Sepolia”).
* Before any signature: modal with **verifyingContract**, **chainId**, **function name**, exact **value**/**deadline**/**nonce**.

### 7) BNPL minimal safe contract interface

* Credit line contract must expose:

  * `maxCredit(address)`, `usedCredit(address)`, `availableCredit(address)`
  * `authorizeSpend(address spender, uint256 amount, uint256 validBefore, bytes32 nonce, bytes sig)`
  * `revoke(bytes32 nonce)`
* The relayer only accepts metasigs that **reduce** availability by the signed amount, never increase it.

# “Lightweight PWA” extras worth doing

* **No install**: add full PWA manifest + splash for low-end devices; but keep the whole app < 200KB gzipped JS.
* **Offline mode**: allow viewing balances/QRs offline; block signing until RPC reachable.
* **QR safety**: render with a whitelist of supported URI schemes (`ethereum:`, `pay:`).
* **Human-readable safety**: explain *why* the app is asking to sign (and that EIP-3009 = **transfer without gas** via relayer).

# Quick test plan (copy/paste)

1. Create a wallet, set passphrase, reload → keys remain locked; inspect Application tab: **no key material in localStorage**.
2. Try to import the same `nonce` twice → second attempt fails (server 409).
3. Switch chains in client; attempt to sign for an **un-allowlisted** contract → blocked.
4. Set `validBefore` in the past; make sure server rejects.
5. Turn SW offline and verify: balances viewable, **send** disabled.

---

If you paste any of these files (e.g., your current key storage, the relayer route that accepts EIP-3009, or the service worker), I’ll mark them up directly. Otherwise, applying the snippets and checks above will close the biggest wallet-class risks without adding bulk.

[1]: https://github.com/mbarbosa30/x4llet "GitHub - mbarbosa30/x4llet"
[2]: https://github.com/mbarbosa30/x4llet/blob/main/vite.config.ts?plain=1 "x4llet/vite.config.ts at main · mbarbosa30/x4llet · GitHub"
